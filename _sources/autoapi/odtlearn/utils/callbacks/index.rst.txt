:py:mod:`odtlearn.utils.callbacks`
==================================

.. py:module:: odtlearn.utils.callbacks


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   odtlearn.utils.callbacks.BendersCallback
   odtlearn.utils.callbacks.RobustBendersCallback



Functions
~~~~~~~~~

.. autoapisummary::

   odtlearn.utils.callbacks.benders_subproblem
   odtlearn.utils.callbacks.robust_tree_subproblem



.. py:function:: benders_subproblem(main_model_obj, b, p, w, i)


.. py:class:: BendersCallback(X, obj, solver, **kwargs)


   Bases: :py:obj:`mip.ConstrsGenerator`

   
   This class contains a function that is called by the solver at
   every node through the branch-&-bound tree while we solve the model.

   We are specifically interested at nodes
   where we get an integer solution for the master problem.
   When we get an integer solution for b and p, for every data-point we solve
   the sub-problem which is a minimum cut and check if g[i] <= value of
   sub-problem[i]. If this is violated we add the corresponding benders
   constraint as lazy constraint to the master problem and proceed.
   Whenever we have no violated constraint, it means that we have found
   the optimal solution.















   ..
       !! processed by numpydoc !!
   .. py:method:: generate_constrs(model: mip.Model, depth: int = 0, npass: int = 0)

      
      Method called by the solver engine to generate *cuts* or *lazy constraints*.

         After analyzing the contents of the solution in model
         variables :attr:`~mip.Model.vars`, whose solution values can
         be queried with the :attr:`~mip.Var.x` attribute, one or more
         constraints may be generated and added to the solver with
         the :meth:`~mip.Model.add_cut` method for cuts. This method
         can be called by the solver engine in two situations, in the first
         one a fractional solution is found and one or more inequalities
         can be generated (cutting planes) to remove this fractional
         solution. In the second case an integer feasible solution is found
         and then a new constraint can be generated (lazy constraint) to
         report that this integer solution is not feasible.  To control when
         the constraint generator will be called set your
         :class:`ConstrsGenerator` object in the attributes
         :attr:`~mip.Model.cuts_generator` or
         :attr:`~mip.Model.lazy_constrs_generator` (adding
         to both is also possible).

      Args:

          model(mip.Model): model for which cuts may be generated. Please note
              that this model may have fewer variables than the original
              model due to pre-processing. If you want to generate cuts
              in terms of the original variables, one alternative is to
              query variables by their names, checking which ones remain
              in this pre-processed problem. In this procedure you can
              query model properties and add cuts (:meth:`~mip.Model.add_cut`) or lazy constraints
              (:meth:`~mip.Model.add_lazy_constr`), but you cannot
              perform other model modifications, such as add columns.
          depth(int): depth of the search tree (0 is the root node)
          npass(int): current number of cut passes in this node















      ..
          !! processed by numpydoc !!


.. py:function:: robust_tree_subproblem(master, i, terminal_nodes, terminal_path_dict, terminal_features_dict, terminal_assignments_dict, terminal_cutoffs_dict, initial_xi={}, initial_mins={}, initial_maxes={})


.. py:class:: RobustBendersCallback(X, obj, solver, **kwargs)


   Bases: :py:obj:`mip.ConstrsGenerator`

   
   This class contains the function called by the solver at every node through
   the branch-&-bound tree while we solve the model.
   We are specifically interested at nodes where we get an integer solution for the master problem.
   When we get an integer solution for b and p, for every datapoint we solve the subproblem
   which is a minimum cut and check if g[i] <= value of subproblem[i].
   If this is violated we add the corresponding benders constraint as lazy constraint to the master
   problem and proceed. Whenever we have no violated constraint, it means that we have found the optimal solution.
















   ..
       !! processed by numpydoc !!
   .. py:method:: generate_constrs(model: mip.Model, depth: int = 0, npass: int = 0)

      
      Method called by the solver engine to generate *cuts* or *lazy constraints*.

         After analyzing the contents of the solution in model
         variables :attr:`~mip.Model.vars`, whose solution values can
         be queried with the :attr:`~mip.Var.x` attribute, one or more
         constraints may be generated and added to the solver with
         the :meth:`~mip.Model.add_cut` method for cuts. This method
         can be called by the solver engine in two situations, in the first
         one a fractional solution is found and one or more inequalities
         can be generated (cutting planes) to remove this fractional
         solution. In the second case an integer feasible solution is found
         and then a new constraint can be generated (lazy constraint) to
         report that this integer solution is not feasible.  To control when
         the constraint generator will be called set your
         :class:`ConstrsGenerator` object in the attributes
         :attr:`~mip.Model.cuts_generator` or
         :attr:`~mip.Model.lazy_constrs_generator` (adding
         to both is also possible).

      Args:

          model(mip.Model): model for which cuts may be generated. Please note
              that this model may have fewer variables than the original
              model due to pre-processing. If you want to generate cuts
              in terms of the original variables, one alternative is to
              query variables by their names, checking which ones remain
              in this pre-processed problem. In this procedure you can
              query model properties and add cuts (:meth:`~mip.Model.add_cut`) or lazy constraints
              (:meth:`~mip.Model.add_lazy_constr`), but you cannot
              perform other model modifications, such as add columns.
          depth(int): depth of the search tree (0 is the root node)
          npass(int): current number of cut passes in this node















      ..
          !! processed by numpydoc !!


